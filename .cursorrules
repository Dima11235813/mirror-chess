# Mirror Chess – AI Contributor Guide (Terse)

**Stack:** Ionic + React + TS + Vite + Vitest
**Layers:**

* `src/game/*`: pure, FP-first chess logic (no side effects; deterministic) – source of truth
* `src/components/*`: React views; render-only; call game APIs
* `src/App.tsx`: thin state container

**Game twist:** Mirror move: `(f,r)` ↔ `(7-f,r)` if path clear; knights ignore blockers.

---

## 1. Priorities

1. Correctness > perf > DX > style
2. Purity/immutability in `src/game/*`
3. Strict TS (no weakening `strict`)
4. DRY + SOLID; UI → game deps only
5. All features ship with tests (unit + e2e where applicable)
6. Backward-compatible exports unless major version

---

## 2. Dependencies

* Use existing runtime deps only
* Testing: Vitest (+ @testing-library/react for components)
* No chess libs, state libs, or global buses without request

---

## 3. Structure

* `src/game`: UI-agnostic pure funcs + types
* Shared utils → `src/game/util`
* Features: add types + logic + tests
* UI in `src/components/*`, explicit props, no hidden state

**Types:**

* Reusable domain types in `src/shared/<domain>/types.ts`
* Game-domain types in `src/game/types.ts`
* Component-local shapes near component; promote if reused

**Components:**

* One component per file
* Non-trivial → folder with `.tsx`, `.types.ts`, `.test.tsx`, `.mocks.ts`
* Props: named `interface` (reuse shared types); no inline object literals
* Optional props only when defined

---

## 4. TypeScript Style

* `readonly` on exported arrays/objects
* Small pure funcs, explicit I/O, no mutation except locals
* Use unions, discriminated unions, exactOptionalPropertyTypes
* No magic strings; centralize in constants (e.g., `WHITE`, `BLACK`, `KINDS`)
* Named types for any shape ≥2 props or reused across modules

---

## 5. Rules Baseline

* Std chess (no castling/en passant yet)
* Mirror: file-mirror move if path clear; knights exempt; captures allowed if target.color ≠ mover
* Reducer applies only legal moves; no check/checkmate yet
* New rules: tests first; mirror logic stays modular

---

## 6. Testing

* Vitest (`.test.ts` near file; `.spec.ts` for e2e in story path)
* Shared mocks in `tests/shared/`
* Bugfixes: add unit + e2e for scenario
* Coverage: happy path + edge cases + negative tests
* Name tests by behavior, not impl
* Always run `npm run test` + `npm run e2e`

---

## 7. Docs

* JSDoc for all exports: desc, invariants, @param/@returns, perf/failure notes
* Update README on user-visible changes

---

## 8. UI/UX

* Board = sole interaction
* Click piece → legal moves (mirror indicated)
* Heavy calc: memoize
* `aria-label` for a11y; no visual-only cues

---

## 9. Performance

* Simple loops; no premature opts
* Avoid re-render storms; compute hints in `useMemo`

---

## 10. Guardrails

* ❌ Relax TS strictness / global state in game layer / change exports w/o tests
* ✅ New rules composable; refactors preserve behavior (add characterization tests first)

---

## 11. Roadmap (1 PR each)

1. isInCheck
2. Filter illegal (self-check) moves
3. Capture UI
4. Game over states
5. Special moves (castling, promo, en passant)
6. Move log + undo
7. Capacitor Android/iOS

---

## 12. Review Checklist

* Types stricter or equal
* All new exports documented
* All tests pass (unit + e2e)
* Build OK (`npm run build`)
* No side effects in `src/game/*`
* No unapproved deps
* UI responsive + a11y intact

---

## 13. Style

* Prefer `for...of` over array `forEach`
* Functions named with verbs; types with nouns